use crate::{game::Game, cfv::*};

pub fn compute_exploitability<G: Game>(game: &G) -> f32 {
    
    let mes_ev = compute_maximally_exploitative_strategy_ev(game);

    if !game.raked() {
        (mes_ev[0] + mes_ev[1]) * 0.5
    } else {
        let current_ev = current_ev(game);
        ((mes_ev[0] - current_ev[0]) + (mes_ev[1] - current_ev[1])) * 0.5
    }
}

fn compute_maximally_exploitative_strategy_ev<G: Game>(game: &G) -> [f32; 2] {

    let mut cfv = [
        Vec::with_capacity(game.num_private_hands(0)),
        Vec::with_capacity(game.num_private_hands(1)),
    ];
    // Counterfactual reach is the probability of a player reaching a node.
    let reach = [game.intial_weights(0), game.intial_weights(1)];

    for player in 0..2 {
        compute_optimal_cfv(
            game,
            &game.root(),
            cfv[player].spare_capacity_mut(),
            player,
            reach[player ^ 1],
        );
        unsafe { cfv[player].set_len(game.num_private_hands(player)) };
    }

    // Weight cfv by probability of reaching node.
    [
        weighted_sum(&cfv[0], reach[0]),
        weighted_sum(&cfv[1], reach[1]),
    ]
}

fn current_ev<G: Game>(game: &G) -> [f32; 2] {

    let mut cfv = [
        Vec::with_capacity(game.num_private_hands(0)),
        Vec::with_capacity(game.num_private_hands(1)),
    ];
    let reach = [game.intial_weights(0), game.intial_weights(1)];

    for player in 0..2 {
        compute_cfv(
            game,
            &mut game.root(),
            cfv[player].spare_capacity_mut(),
            player,
            reach[player ^ 1],
            false,
        );
        unsafe { cfv[player].set_len(game.num_private_hands(player)) };
    }

    [
        weighted_sum(&cfv[0], reach[0]),
        weighted_sum(&cfv[1], reach[1]),
    ]
}

fn weighted_sum(vals: &[f32], weights: &[f32]) -> f32 {
    let f = |sum: f64, (&v, &w): (&f32, &f32)| sum + v as f64 * w as f64;
    vals.iter().zip(weights).fold(0.0, f) as f32
}